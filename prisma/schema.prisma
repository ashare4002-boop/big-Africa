generator client {
  provider = "prisma-client"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
}



/*
  Added CourseType enum, Town and Infrastructure models.
  Modified Course to include courseType and relation to Town.
  Modified Enrollment to link optionally to Infrastructure and to support subscription/ejection fields.
*/

model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt
  sessions      Session[]
  accounts      Account[]
  courses       Course[]
  enrollment    Enrollment[]
  notifications Notification[]

  nkwaCustomerId String? @unique

  banned     Boolean?  @default(false)
  banReason  String?
  banExpires DateTime?

  role String?

  // Platform-wide monthly subscription (1000 XAF/month)
  trialStartedAt         DateTime?  // When user started their 7-day trial
  monthlySubscriptionPaidUntil DateTime? // When their current monthly subscription expires
  hasAcceptedTrial       Boolean    @default(false) // Tracks if user started trial from landing page

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

enum CourseLevel {
  Beginner
  Intermediate
  Advanced
  GCE
  Concour
  Probatoire
  BAC
  none
}

enum CourseStatus {
  Draft
  Published
  Archived
}

/*
 New enum for course types
*/
enum CourseType {
  NORMAL
  INFRASTRUCTURE_BASE
}

enum DurationType {
  DAYS
  WEEKS
  MONTHS
}

model Course {
  id          String      @id @default(uuid())
  title       String
  description String
  filekey     String
  price       Int // <---- Think making this optional and use the .optional() in the schema definition of prisma
  duration    Int
  level       CourseLevel
 
  category         String
  smallDescription String
  slug             String @unique

  status CourseStatus @default(Draft)

  // new courseType field: NORMAL or INFRASTRUCTURE_BASE
  courseType CourseType @default(NORMAL)

  createdAt DateTime @default(now())
  updateAt  DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  chapters Chapter[]
  enrollment Enrollment []

  // towns associated with this course (for infrastructure base courses)
  towns Town[]
}

model Chapter {
  id String @id @default(uuid())

  title    String
  position Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Course    Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  courseId  String

  lesson Lesson[]
}
  
model Lesson {
  id String @id @default(uuid())

  title        String
  description  String?
  position     Int
  thumbnailKey String?
  videoKey     String?
  content      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Chapter   Chapter  @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  chapterId String

  blocks LessonBlock[]

  @@index([chapterId])
}

/*
 Town model: a Course can have many Towns
*/
model Town {
  id        String   @id @default(uuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relation to course
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
  courseId String

  // infrastructures in this town
  infrastructures Infrastructure[]
}

/*
 Infrastructure model: physical locations
 - tutorNames: stored as String[] (Postgres text[])
 - images: stored as String[] (1..3 expected, not enforced at DB layer)
 - openTime/closeTime: DateTime (can store times or datetimes; adjust as needed)
*/
model Infrastructure {
  id                String   @id @default(uuid())
  name              String
  capacity          Int
  currentEnrollment Int      @default(0)
  location          String
  publicContact     String
  privateContact    String
  ownerPhoneNumber  String   // MTN or Orange phone number for mobile money
  openTime          DateTime?
  closeTime         DateTime?
  tutorNames        String[]  // list of tutor names
  facilityImageKey  String   // image of the infrastructure building
  locationImageKey  String   // image showing location on map
  enrollmentDeadline DateTime?
  duration          Int      // course duration number
  durationType      DurationType @default(MONTHS) // DAYS, WEEKS, or MONTHS
  isLocked          Boolean  @default(false) // manually locked by admin
  totalEarnings     Float    @default(0) // track earnings for this infrastructure

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  town        Town   @relation(fields: [townId], references: [id], onDelete: Cascade)
  townId      String

  // optional enrollments referencing this infrastructure
  enrollment Enrollment[]
}

/*
 Enrollment model updates:
 - optional relation to Infrastructure
 - subscription/ejection fields: lastPaidDate, isEjected, ejectionCount
*/
model Enrollment {
  id String @id  @default(uuid())

  amount  Int
  status EnrollmentStatus @default(Pending)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
  courseId String
  User User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@unique([userId, courseId])

  // payment fields
  transactionId String? @unique
  provider      String? 
  rawResponse   Json?   
  paidAt        DateTime?

  // infrastructure-specific fields
  infrastructure Infrastructure? @relation(fields: [infrastructureId], references: [id], onDelete: SetNull)
  infrastructureId String?

  // subscription/ejection logic
  lastPaidDate DateTime?
  nextPaymentDue DateTime? // when the next monthly payment is due
  isEjected    Boolean  @default(false)
  ejectionCount Int     @default(0)
  canReEnroll   Boolean  @default(false) // true if user was ejected and can reclaim their spot
  warningEmailSent Boolean @default(false) // track if 3-day pre-expiration warning was sent

}

/*
 Enrollment status enum already existed; kept for compatibility
*/
enum EnrollmentStatus {
 Pending
 Active
 Cancelled
 Paid
}

model LessonBlock {
  id       String          @id @default(uuid())
  type     LessonBlockType
  position Int
  data     Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  lesson    Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  lessonId  String

  @@index([lessonId])
}

enum LessonBlockType {
  TEXT
  IMAGE
  VIDEO
  QUIZ
  FILE
}

enum NotificationType {
  PAYMENT_WARNING
  SUBSCRIPTION_WARNING
  EJECTION
  PAYMENT_RECEIVED
}

model Notification {
  id String @id @default(uuid())
  
  type NotificationType
  title String
  message String
  daysRemaining Int?
  amountDue Int?
  enrollmentId String?
  read Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  
  @@index([userId])
  @@index([read])
}